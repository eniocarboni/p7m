#! /bin/bash

# ----------------------------------------
# p7m: script for the management of files with digital signature in the CADES format.
# See: https://github.com/eniocarboni/p7m
# Author: Enio Carboni
# Version: 0.4
# ----------------------------------------

# ---------------------------------------
# Main Global variables:
# You can modify these variables but I recommend doing this using the configuration file $CONF_DIR/p7m_config
# ---------------------------------------

# DWL_ORDER: Order to choose for download program
DWL_ORDER="wget curl GET"
# DIALOG_ORDER: Order to choose of x graphic dialog
DIALOG_ORDER="kdialog zenity xmessage"
# OPEN_ORDER: Order to choose for opening program
OPEN_ORDER="xdg-open gvfs-open gnome-open"
# CA_OLD_TIME_SEC: after that second the CA file will be download
CA_OLD_TIME_SEC=1296000
# XML_CERTS: url of cnipa xml certs
#XML_CERTS='https://applicazioni.cnipa.gov.it/TSL/_IT_TSL_signed.xml'
# See https://www.agid.gov.it/it/piattaforme/firma-elettronica-qualificata/certificati
XML_CERTS='https://eidas.agid.gov.it/TL/TSL-IT.xml'
# ROTATE_NUMBER: number of rotations (for same files)
ROTATE_NUMBER=10
# MIMETYPES: path of file mime.types
MIMETYPES=/etc/mime.types
CONF_DIR=${HOME}/.config/p7m
DOWN_RIGHT_ARROW="\u21b3"
# Terminal color
RED='\033[0;31m'
BWhite='\033[1;37m'
BPurple='\033[1;35m'
BRed='\033[1;31m'
NC='\033[0m' # No Color
# Fattura Elettronica PA
XSL_V11="fatturapa_v1.1.xsl"
XSL_V11_URL="https://www.fatturapa.gov.it/export/fatturazione/sdi/fatturapa/v1.1/fatturapa_v1.1.xsl"
XSL_V12="fatturapa_v1.2.1.xsl"
XSL_V12_URL="https://www.fatturapa.gov.it/export/fatturazione/sdi/fatturapa/v1.2.1/fatturaPA_v1.2.1.xsl"
# XSL_OLD_TIME_SEC: after that second the xsl file will be download
XSL_OLD_TIME_SEC=1296000
# ------------------------------------------------------------------------

declare -A msg
# msg: multilang phrases (it [default], en)
# Consider only the first 2 characters of the language (example it, en)

# it phrases
msg[it:titolo:p7m]="P7M"
msg[it:titolo:seleziona:p7m]="Seleziona un p7m"
msg[it:titolo:openssl]="Openssl"
msg[it:titolo:openssl:verify]="Openssl verifica firma"
msg[it:titolo:openssl:cert]="Openssl Certificato"
msg[it:titolo:openssl:asn1parse]="Openssl debug"
msg[it:titolo:download]="Download"
msg[it:titolo:cert]="Cert"
msg[it:titolo:errore]="Errore"
msg[it:titolo:attenzione]="Attenzione"
msg[it:titolo:dettagli]="Dettagli"

msg[it:errore:file:ext]="Bisogna passare un file con estensione .p7m come parametro"
msg[it:errore:file:ext:bad]="Formato del file p7m non riconosciuto."
msg[it:errore:file:non_esiste]="Non esiste il file. Controllare meglio"
msg[it:errore:file:conf_dir]="Impossibile creare la directory .p7m nella tua HOME"
msg[it:openssl:estrazione:errore]="estrazione file terminata con errore"
msg[it:openssl:verifica:errore:formato]="Errore nel formato del file"
msg[it:openssl:verifica:title:ok]="Verifica firme avvenuta con successo"
msg[it:openssl:verifica:title:non_ok]="Verifica firme terminata con errore"
msg[it:openssl:verifica:ok:ok]="**Firmatario: %s**\n   Data e ora di firma: %p1\n   Ente: %p2\n   CF: %p3\n   Certificatore: %p4\n   Validità certificato: %p5 - %p6\n"
msg[it:openssl:verifica:non_ok:ok]="**Firmatario: %s**\n   Data e ora di firma: %p1\n   Ente: %p2\n   CF: %p3\n   Certificatore: %p4\n   ** Certificato non valido: %p5 - %p6\n"
msg[it:openssl:verifica:non_ok_scaduto:ok]="**Firmatario: %s**\n   Data e ora di firma: %p1\n   Ente: %p2\n   CF: %p3\n   Certificatore: %p4\n   ***Certificato scaduto: %p5 - %p6***\n"
msg[it:openssl:verifica:non_ok_scaduto:non_ok]="**Firmatario: %s**\n   *** Errore in data e ora di firma: %p1***\n   Ente: %p2\n   CF: %p3\n   Certificatore: %p4\n   *** Certificato scaduto: %p5 - %p6***\n"
msg[it:openssl:verifica:non_ok:non_ok]="**Firmatario: %s**\n   *** Errore in data e ora di firma: %p1***\n   Ente: %p2\n   CF: %p3\n   Certificatore: %p4\n   *** Errore nel certificato validità: %p5 - %p6***\n"
msg[it:openssl:verifica:errore:continuo]="Verifica documento e/o firme errate! Provo comunque ad estrarre il contenuto?"
msg[it:openssl:verifica:timestamp:mancante]="Manca il timestamps nel p7m"
msg[it:openssl:cert:errore]="Impossibile estrarre il certificato"
msg[it:openssl:cert:validita]="Validità certificato: %s"
msg[it:openssl:asn1parse:error]="Impossibile estrarre informazioni dal file"
msg[it:openssl:asn1parse:timestamp]="Riferimento temporale: %s"
msg[it:openssl:estrazione:percorso]="Estratto il file in "
msg[it:eseguibile:openssl:non_trovato]="Devi installare 'openssl' prima di poter usare questo programma"
msg[it:eseguibile:open_file:non_trovato]="Non trovo nessuno dei comandi:\n ${OPEN_ORDER}\nNon so come aprire il file estratto"
msg[it:eseguibile:download_url:non_trovato]="Nessun programma di download trovato! Impossibile continuare."
msg[it:download_url:ca:ok]="CA scaricato perfettamente in"
msg[it:download_url:ca:non_ok]="Impossibile scaricare il CA in questo momento ... riprovare successivamente"
msg[it:download_url:ca:mancante]="Manca il CA, scaricarlo con l'opzione -p"
msg[it:download_url:ca:attendi]="Inizio scaricamento CA ... attendi un attimo"
msg[it:download_url]="Inizio scaricamento %s ... attendi un attimo"
msg[it:file:diritti:scrittura]="Impossibile scrivere in "
msg[it:file:diritti:scrittura:alternativa]="Estratto comunque il file in "
msg[it:file:sovrascivere]="Sovrascrivere il file "
msg[it:p7m:usage]="***%s***

Usare:
  **p7m** [-x] [-g] [-h] <file.p7m> # Per estrarre il contenuto
  **p7m** -v [-g] [-h] <file.p7m>   # Per verificare il p7m
  **p7m** -c [-g] [-h] <file.p7m>   # Per i certificati
  **p7m** -d [-g] [-h] <file.p7m>   # Per il debug (esperti)
  **p7m** -p [-h]                   # Per scaricare la nuova CA

  Dove:
    **-h**: visualizza questo messaggio;
    **-x**: estrae il file e non tenta di visualizzarlo;
    **-v**: per verificare il p7m e la validita dei certificati e delle firme;
    **-c**: visualizza i certificati di firma sia come testuali che come certificati binari (in formato PEM);
    **-p**: per forzare lo scaricamento dei nuovi certificati;
    **-d**: utili per il debug del p7m (per esperti);
    **-g**: prova ad utilizzare finestre grafiche invece di scrivere in console.
"

# en phrases
msg[en:titolo:p7m]="P7M"
msg[en:titolo:seleziona:p7m]="Select a p7m file"
msg[en:titolo:openssl]="Openssl"
msg[en:titolo:openssl:verify]="Openssl verifica firma"
msg[en:titolo:openssl:cert]="Openssl Certificato"
msg[en:titolo:openssl:asn1parse]="Openssl debug"
msg[en:titolo:download]="Download"
msg[en:titolo:cert]="Cert"
msg[en:titolo:errore]="Error"
msg[en:titolo:attenzione]="Warning"
msg[en:titolo:dettagli]=" Details"
msg[en:errore:file:ext]="You must pass a .p7m file as a parameter"
msg[en:errore:file:ext:bad]="Bad file p7m format."
msg[en:errore:file:non_esiste]="There is no file. Check better"
msg[en:errore:file:conf_dir]="Unable to create the .p7m directory in your HOME"
msg[en:openssl:estrazione:errore]="File extraction ended with error"
msg[en:openssl:verifica:errore:formato]="File format error"
msg[en:openssl:verifica:ok:ok]="Signature verified correctly (timestamps within the validity of the certificate)\n\nThe signature was made in %s from %p1\nOrganization: %p2\nTax code: %p3\nIssuer: %p4"
msg[en:openssl:verifica:non_ok:ok]="Signature verification failed but timestamps within the validity of the certificate"
msg[en:openssl:verifica:non_ok_scaduto:ok]="Signature verification failed (certificate expired) but timestamps within the validity of the certificate\n\nThe signature was made in %s from %p1\nOrganization: %p2\nTax code: %p3\nIssuer: %p4"
msg[en:openssl:verifica:non_ok:non_ok]="Signature verification failed and timestamps failed, outside the validity of the certificate"
msg[en:openssl:verifica:non_ok_scaduto:non_ok]="Signature verification failed (certificate expired) and timestamps failed, outside the validity of the certificate\n\nThe signature was made in %s from %p1\nOrganization: %p2\nTax code: %p3\nIssuer: %p4"
msg[en:openssl:verifica:errore:continuo]="Verification document and/or signatures incorrect! Do I still try to extract the content?"
msg[en:openssl:verifica:timestamp:mancante]="missed timestamps in p7m"
msg[en:openssl:cert:errore]="Unable to extract the certificates"
msg[en:openssl:cert:validita]="Certificate validity:: %s"
msg[en:openssl:asn1parse:error]="Unable to exact any info from this file"
msg[en:openssl:asn1parse:timestamp]="Timestamps: %s"
msg[en:openssl:estrazione:percorso]="Extract the file in "
msg[en:eseguibile:openssl:non_trovato]="You must install openssl first"
msg[en:eseguibile:open_file:non_trovato]="Extract the file"
msg[en:eseguibile:download_url:non_trovato]="No download program found! It is not possible to continue."
msg[en:download_url:ca:ok]="CA downloaded perfectly into"
msg[en:download_url:ca:non_ok]="Unable to download the 'CA' at this time ... try again later"
msg[en:download_url:ca:mancante]="The CA is missing, download it with the -p option"
msg[en:download_url:ca:attendi]="Starting download the CA ... wait, please"
msg[en:download_url]="Starting download %s ... wait, please"
msg[en:file:diritti:scrittura]="Unable to write in "
msg[en:file:diritti:scrittura:alternativa]="Extract the file in "
msg[en:file:sovrascivere]="Overwrite the file "
msg[en:p7m:usage]="***%s***

Use:
  **p7m** [-x] [-g] [-h] <file.p7m> # To extract content
  **p7m** -v [-g] [-h] <file.p7m>   # To verify p7m
  **p7m** -c [-g] [-h] <file.p7m>   # Certificates
  **p7m** -d [-g] [-h] <file.p7m>   # To debug (expert only)
  **p7m** -p [-h]                   # To download the CA

  Where:
    **-h**: Display this help;
    **-x**: extract the content without display it;
    **-v**: verify p7m, certificates and the signs;
    **-c**: display certificates;
    **-p**: force CA download;
    **-d**: p7m debug (expert only);
    **-g**: try using graphical windows instead of writing in console.
"
# P7MTYPE: 
#   smime: use openssl smime
#   cms  : use new openssl cms
# Inizialized calling getP7mType() function
P7MTYPE=''
# ------------------------------------------------------------------------

# ============================= #
# From here the functions begin #
# ============================= #

# get_lang_message()
# --------------------------
# Description: Get 2 digit lang based on $LANG environment variable
# Input params: <none>
# Environment variables used: $LANG
# Output: 2 digit lang (default "it") 
# Return value: 0
# --------------------------
get_lang_message() {
	local L
	L=${LANG%.*}
	L=${L%_*}
	if [ "$L" = "C" ]; then 
		L='en'
	elif [ -z "$L" ]; then
		L='it'
	fi
	echo $L
}

# _msg()
# --------------------------
# Description: Display the message with the right language associated with the tag passed as a parameter
# Input params: 
#  $1: Key to obtain the phrase in the right language.
#  $2, ..., $10: Dynamic Parameters to replace some phrases.
# Global variables used: $msg
# Output: The phrase in the right language.
# Return value: 0
# --------------------------
_msg() {
	local value=''
	if [ -z "$1" ]; then
		return 0
	fi
	if [ -n "${msg[$L:$1]}" ]; then
		value="${msg[$L:$1]}"
	else 
		value="${msg[it:$1]}"
	fi
	if [ -n "$2" ]; then
		value=$(echo "$value" | sed "s/\%s/$2/g")
		value=$(echo "$value" | sed "s/\%p1/$3/g")
		value=$(echo "$value" | sed "s/\%p2/$4/g")
		value=$(echo "$value" | sed "s/\%p3/$5/g")
		value=$(echo "$value" | sed "s/\%p4/$6/g")
		value=$(echo "$value" | sed "s/\%p5/$7/g")
		value=$(echo "$value" | sed "s/\%p6/$8/g")
		value=$(echo "$value" | sed "s/\%p7/$9/g")
		value=$(echo "$value" | sed "s/\%p8/$10/g")
	fi
	echo "$value"
}
# rotate_file()
# --------------------------
# Description: Rotate the file passed by parameter add to the name ".1", ".2", ... ".n" where "n" is at the most $ROTATE_NUMBER
# Input params: 
#  $1: The file to rotate the name
# Global variables used: $ROTATE_NUMBER
# External commans used: seq, mv
# Output: <none>
# Return value: the ret value of "mv" command (generally "0")
# --------------------------
rotate_file() {
	local rotate=0
	local r=''
	local rr=''
	if [ -z "$1" -o ! -f "$1" ]; then 
		return
	fi
	rotate=$((${ROTATE_NUMBER} -1))
	for r in `seq ${rotate} -1 1`; do
		rr=$(($r+1))
		if [ -f "$1.$r" ]; then
			mv "$1.$r" "$1.$rr"
		fi
	done
	mv "$1" "$1.1"
}

# find_command()
# --------------------------
# Description: Check if the command passed as a parameter actually exists.
# Input params: 
#  $1: command to verify
# External commans used: which
# Output: Complete command path or nothing if not existing.
# Return value: 0
# --------------------------
find_command() {
	local com=''
	local c=''
	for c in "$@"; do
		if [ `which ${c} 2>/dev/null` ]; then
			com=${c}
			break
		fi
	done
	echo $com
}

# del_oldtmp_file()
# --------------------------
# Description: Delete temporary files created previously
#   Before the cancellation there are security checks:
#   - do not delete the original file;
#   - the final extracted file must not be deleted;
#   - the file must exist;
#   - the file must be of the temporary type created by this script (must match "p7m_").
# Input params: 
#  $1, ..., $n: Names of files to be deleted.
# Global variables used: $p7m_attach, $file
# External commans used: rm
# Output: <none>
# Return value: 0
# --------------------------
del_oldtmp_file() {
	local f=''
	for f in $@; do
		if [ "$f" != "$file" -a "$f" != "${p7m_attach}" -a -e "$f" -a "$f" != "${f/p7m_}" ]; then
			rm -f "$f"
		fi
	done
	return 0
}

# download()
# --------------------------
# Description: Download $1 url and save it as $2
#   For download, either wget or curl or GET is used. The download log is located in ${CONF_DIR}/.dwn.log
# Input params: 
#  $1: url to download
#  $2: Name and path of downloaded url
# Global variables used: $msg, $CONF_DIR, $DWN
# External commans used: touch, wget, curl, GET
# Phrases key used: eseguibile:download_url:non_trovato, titolo:download
# Output: <none>
# Return value: Return value of either wget or curl or GET (0 if ok)
# --------------------------
download() {
	rotate_file "${CONF_DIR}/.dwn.log"
	touch "${CONF_DIR}/.dwn.log"
	if [ -z "${DWN}" ]; then 
		err "$(_msg "eseguibile:download_url:non_trovato")\n[${DWL_ORDER}]" "$(_msg "titolo:download")"
		exit 1
	fi
	if [ ${DWN} = 'wget' ]; then
	        wget --tries=2 -o ${CONF_DIR}/.dwn.log -O "$2" "$1"
	elif [ ${DWN} = 'curl' ]; then
		curl --progress-bar -v -o "$2" --retry 2 "$1" 2>${CONF_DIR}/.dwn.log
	elif [ ${DWN} = 'GET' ]; then
		GET "$1" >"$2"
	fi
	return $?
}

# call_kdialog()
# --------------------------
# Description: Use kdialog to view a message.
#   kdialog can display the text in html so the message is converted by replacing:
#   - spaces with & nbsp;
#   - a sentence enclosed between left and right by 3 '*' with <font color = "red"> ... </font>
#   - a sentence enclosed between left and right by 2 '*' with <b> ... </b>
#   - the end of line with <br>
# Input params: 
#  $1: Type of window: 
#    text      : --textbox if lenght $2 > 40960 characters else --msgbox
#    warn      : --sorry
#    err       : --error
#    err_detail: --detailederror
#    notify    : --passivepopup
#    warn_yesno: --warningyesno
#  $2: text to display
#  $3: title (for --detailederror and --warningyesno is detailed info of $2)
#  $4: title only for --detailederror and --warningyesno
# External commans used: kdialog, sed, mktemp
# Output: kdialog windows
# Return value: kdialog return
# --------------------------
call_kdialog() {
	local t='<html>'$(echo -e  "$2" | sed -e 's/ /\&nbsp;/g' -e 's/\*\*\*\(.*\)\*\*\*/<font color="red">\1<\/font>/g' -e 's/\*\*\(.*\)\*\*/<b>\1<\/b>/g' -e 's/$/<br>/g')'</html>'
	local t2='<html>'$(echo -e  "$2<br><br><i>$3</i>" | sed -e 's/ /\&nbsp;/g' -e 's/\*\*\*\(.*\)\*\*\*/<font color="red">\1<\/font>/g' -e 's/\*\*\(.*\)\*\*/<b>\1<\/b>/g' -e 's/$/<br>/g')'</html>'
	local log_file=''
	if [ $1 = 'text' ]; then
		if [ ${#2} -gt 40960 ]; then
			log_file=$(mktemp --tmpdir "p7m_tmp.XXXXXXXXXX")
			echo -e  "$2" >$log_file
			kdialog --title "$3" --textbox "$log_file" --geometry 800x600 2>/dev/null
			rm -f $log_file
		else
			kdialog --title "$3" --msgbox "$t" 2>/dev/null
		fi
	elif [ $1 = 'warn' ]; then
		kdialog --title "$3" --sorry "$t" 2>/dev/null
	elif [ $1 = 'err' ]; then
		kdialog --title "$3" --error "$t" 2>/dev/null
	elif [ $1 = 'err_detail' ]; then
		kdialog --title "$4" --detailederror "$t" "$3" 2>/dev/null
	elif [ $1 = 'notify' ]; then
		kdialog --title "$3" --passivepopup "$1" 5 2>/dev/null
	elif [ $1 = 'warn_yesno' ]; then
		kdialog --title "$4" --warningyesno "$t2" 2>/dev/null
	fi
}
# call_zenity()
# --------------------------
# Description: Use zenity to view a message.
# Input params: 
#  $1: Type of window:
#    text      : --text-info if length $2 >= 150 else --info
#    warn      : --warning
#    err       : --error
#    err_detail: --error
#    notify    : --notification
#    warn_yesno: --question
#  $2: text to display
#  $3: title
#  $4: detailed text to display
# External commans used: zenity 
# Output: zenity windows
# Return value: zenity return
# --------------------------
call_zenity() {
	if [ $1 = 'text' ]; then
		if [ ${#2} -gt 150 ]; then 
			echo -e "$2" | zenity --text-info --width=600 --height=500 --title="$3" 2>/dev/null
		else
			zenity --info --title="$3" --text="$2" 2>/dev/null
		fi
	elif [ $1 = 'warn' ]; then
		zenity --warning --title="$3" --text="$2" 2>/dev/null
	elif [ $1 = 'err' ]; then
		zenity --error --title="$3" --text="$2" 2>/dev/null
	elif [ $1 = 'err_detail' ]; then
		zenity --error --title="$4" --text="$2\n\n$3" 2>/dev/null
	elif [ $1 = 'notify' ]; then
		zenity --notification --title="$3" --text="$2" 2>/dev/null
	elif [ $1 = 'warn_yesno' ]; then
		zenity --question --title="$4" --text="$2\n\n$3" 2>/dev/null
	fi
}
# call_xmessage()
# --------------------------
# Description: Use xmessage to view a message.
# Input params: 
#  $1: Type of window: text, warn, err, err_detail, notify, warn_yesno
#  $2: text to display
#  $3: for err_detail and warn_yesno is detailed info of $2
# External commans used: xmessage
# Output: xmessage windows
# Return value: xmessage return
# --------------------------
call_xmessage() {
	if [ $1 = 'text' ]; then
		echo -e "$2" | xmessage -nearmouse -file - 2>/dev/null
	elif [ $3 = 'warn' ]; then
		echo -e "$2" | xmessage -nearmouse -file - 2>/dev/null
	elif [ $1 = 'err' ]; then
		echo -e "$2" | xmessage -nearmouse -file - 2>/dev/null
	elif [ $1 = 'err_detail' ]; then
		echo -e "$2\n\n$3" | xmessage -nearmouse -file - 2>/dev/null
	elif [ $1 = 'notify' ]; then
		echo -e "$2"
	elif [ $1 = 'warn_yesno' ]; then
		echo -e "$2\n\n$3"
	fi
}
# call_echo()
# --------------------------
# Description: Use echo to view a message.
# Input params: 
#  $1: Type of window: text, warn, warn_yesno
#  $2: text to display
#  $3: title (for  err_detail and warn_yesno is detailed info of $2)
#  $4: detailed info of $2 for err_detail and warn_yesno
# External commans used: sed
# Output: echo message.
# Return value: 0 or 1 if warn_yesno and the answer is different from 's' or 'y'.
# --------------------------
call_echo() {
	# controllo se l'output va nel terminale o in una pipe
	local ret=0
	local t=''
	local answer=''
	if [ -t 1 ]; then
		t=$(echo -e "${BRed}$4${NC}\n$2" | sed -e "s/\*\*\*\(.*\)\*\*\*/\\\033[0;31m\1\\\033[0m/g" -e "s/\*\*\(.*\)\*\*/\\\033[1;37m\1\\\033[0m/g")
		# Title
		if [ -n "$3" ]; then 
			if [ $1 = 'text' ]; then
				echo -e "${BWhite}$3${NC}"
			elif [ $1 = 'warn' ]; then
				echo -e "${BPurple}$3${NC}"
			elif [ $1 = 'warn_yesno' ]; then
				echo -e "${BPurple}$3${NC}"
			else 
				echo -e "${BRed}$3${NC}"
			fi
		fi
		# Text
		if [ $1 = 'warn_yesno' ]; then
			read -s -n 1 -p "$t [s/n] " answer
			answer=$(echo ${answer} | tr '[A-Z]' '[a-z]')
			if [ -z "$answer" ]; then
				answer=" "
			fi
			if [ "$answer" = 's' -o "$answer" = 'y' ]; then
				ret=0
			else
				ret=1
			fi
		else 
			echo -e "$t"
		fi
		echo
	else
		if [ -n "$1" ]; then 
			echo -e "$3"
		fi
		echo -e  "$2"
	fi
	return $ret
}
# display()
# --------------------------
# Description: Display a text message using the right dialog message
# Input params: 
#  $1, ..., $n: parameters like in call_xyz function (see call_kdialog for example) 
# Global variables used: XDIALOG, $out
# Output: the dialog message
# Return value: the return from the dialog message
# --------------------------
display() {
	if [ "${out}" = 'g' -a -n "${XDIALOG}" ]; then
		call_${XDIALOG} "text" "$@"
	else
		call_echo "text" "$@"
	fi
}
# notify()
# --------------------------
# Description: Display a notify message using the right dialog message
# Input params: 
#  $1, ..., $n: parameters like in call_xyz function (see call_kdialog for example)
# Global variables used: XDIALOG, $out
# Output: the dialog message
# Return value: the return from the dialog message
# --------------------------
notify() {
	if [ "${out}" = 'g' -a -n "${XDIALOG}" ]; then
		call_${XDIALOG} "notify" "$@"
	else

		call_echo "text" "$@"
	fi
}
# warn()
# --------------------------
# Description: Display a warn message using the right dialog message
# Input params: 
#  $1, ..., $n: parameters like in call_xyz function (see call_kdialog for example)
# Global variables used: XDIALOG, $out
# Output: the dialog message
# Return value: the return from the dialog message
# --------------------------
warn() {
	if [ "${out}" = 'g' -a -n "${XDIALOG}" ]; then
		call_${XDIALOG} "warn" "$@"
	else
		call_echo "warn" "$@"
	fi
}
# err()
# --------------------------
# Description: Display a err message using the right dialog message
# Input params: 
#  $1, ..., $n: parameters like in call_xyz function (see call_kdialog for example)
# Global variables used: XDIALOG, $out
# Output: the dialog message
# Return value: the return from the dialog message
# --------------------------
err() {
	if [ "${out}" = 'g' -a -n "${XDIALOG}" ]; then
		call_${XDIALOG} "err" "$@"
	else
		call_echo "err" "$@"
	fi
}
# err_detail()
# --------------------------
# Description: Display a err_detail message using the right dialog message
# Input params: 
#  $1, ..., $n: parameters like in call_xyz function (see call_kdialog for example)
# Global variables used: XDIALOG, $out
# Output: the dialog message
# Return value: the return from the dialog message
# --------------------------
err_detail() {
	if [ "${out}" = 'g' -a -n "${XDIALOG}" ]; then
		call_${XDIALOG} "err_detail" "$@"
	else
		call_echo "err" "$1" "$3" "$2"
	fi
}
# warn_yesno()
# --------------------------
# Description: Display a warn_yesno message using the right dialog message
# Input params: 
#  $1, ..., $n: parameters like in call_xyz function (see call_kdialog for example)
# Global variables used: XDIALOG, $out
# Output: the dialog message
# Return value: the return from the dialog message
# --------------------------
warn_yesno() {
	if [ "${out}" = 'g' -a -n "${XDIALOG}" ]; then
		call_${XDIALOG} "warn_yesno" "$@"
	else
		call_echo "warn_yesno" "$1" "$3" "$2"
	fi
}
	

# opensslVerify()
# --------------------------
# Description: start openssl command to verify the p7m file either in smime or cms
# Input params: 
#  $1: p7m file to verify
#  $2: format (DER or PEM). Default to DER
#  $3: no_out (no output like -out /dev/null 2>&1)
# Global variables used: $P7MTYPE, $CONF_DIR
# Output: the output of openssl command used
# Return value: the return from the openssl command
# --------------------------
opensslVerify() {
	local format="DER"
	local noout='';
	if [ -n "$2" ]; then
		format="$2"
	fi
	if [ -n "$3" -a "$3" = "no_out" ]; then
		noout='-out /dev/null 2>/dev/null'
		openssl ${P7MTYPE} -verify -CAfile "${CONF_DIR}/ca.pem" -in "$1" -inform "$format" -out /dev/null 2>/dev/null
	else
		openssl ${P7MTYPE} -verify -CAfile "${CONF_DIR}/ca.pem" -in "$1" -inform "$format"
	fi
	return $?
}

# opensslTextStruct()
# --------------------------
# Description: Display text info of p7m struct
# Input params: 
#  $1: p7m file to info
# Global variables used: $P7MTYPE
# Output: the output of openssl command used
# Return value: the return from the openssl command
# --------------------------
opensslTextStruct() {
	local ret
	if [ "${P7MTYPE}" = "smime" ]; then
		# smime
		openssl pkcs7 -print -text -inform der -in "$1"
		ret=$?
	else
		# cms
		openssl cms -inform DER -verify -noverify -nosigs -cmsout -print -text -in "$1"
		ret=$?
	fi
	return "$ret"
}

# getIssuerTimestamps()
# --------------------------
# Description: Display the serials and timestamps of the signers
# Input params: 
#  $1: p7m file
# Global variables used: $P7MTYPE
# Output: For each signers display the cert's serial in the first line and the timestamp in the second line
#         the timestamp is normalized in your localtime
# Return value: the return from the openssl command
# --------------------------
getIssuerTimestamps() {
	local info=$(opensslTextStruct "$1")
	local ret=$?
	if [ "${P7MTYPE}" = "smime" ]; then
		# smime
		echo "$info" | sed -n '/issuer_and_serial:/,/UTCTIME:/p'| grep -E ' serial:|UTCTIME:'| sed -e 's/^ *serial: *//' -e 's/^ *UTCTIME: *//'
	else
		# cms
		echo "$info" | sed -n '/issuerAndSerialNumber:/,/UTCTIME:/p' | grep -E ' serialNumber:|UTCTIME:' | sed -e 's/^ *serialNumber: *//' -e 's/^ *UTCTIME: *//'
	fi
	return $ret
}

# getCertsFields()
# --------------------------
# Description: Display the main fields of the certs of the signers
# Input params: 
#  $1: p7m file
# Global variables used: $P7MTYPE
# Output: For each signers display the main cert's fields one for each line:
#         In 1st line display the serialNumber,
#         in 2nd line the issuer,
#         in 3rd line the notBefore date,
#         in 4th line the notAfter date,
#         in 5th line the subject
# Return value: the return from the openssl command
# --------------------------
getCertsFields() {
	local info=$(opensslTextStruct "$1")
	local ret=$?
	# smime and cms output are both ok
	echo "$info" | sed -n '/cert_info:/,/issuerUID:/p'| grep -E ' serialNumber:|issuer:|notBefore:|notAfter:|subject:' | grep -E ' serialNumber:|issuer:|notBefore:|notAfter:|subject:' | sed 's/^ *\(serialNumber:\|issuer:\|notBefore:\|notAfter:\|subject:\) *//'
	return $ret
}

# getTs()
# Description: return the second from origin based on date in $1
# Input params:
#  $1: the date to convert
# Output: The second from origin
# Return value: the return value of date command
# --------------------------
getTs() {
	local ts=$(date --date="$1" "+%s")
	local ret=$?
	echo "$ts"
	return $ret
}

# getCn()
# Description: return the CN from a cert subject field as $1
# Input params:
#  $1: the subject
# Output: The CN
# Return value: 0
# --------------------------
getCn() {
	echo "$1" |sed -e 's/^.*CN=//' -e 's/[\/,].*$//' 2>&1
	return 0
}

# getCf()
# Description: return the CF from a cert subject field as $1
# Input params:
#  $1: the subject
# Output: The CF (codice fiscale)
# Return value: 0
# --------------------------
getCf() {
	echo "$1" | sed -e 's/^.*serialNumber=//' -e 's/[\/,].*$//' -e 's/^.*://' 2>&1
	return 0
}

# getOu()
# Description: return the OU from a cert subject field as $1
# Input params:
#  $1: the subject
# Output: The OU
# Return value: 0
# --------------------------
getOu() {
	local subject=$1
	local ou="non presente"
	if [ "$subject" != "${subject/O=}" ]; then
		ou=$(echo $subject |sed -e 's/^.*O=//' -e 's/[\/,].*$//' -e 's/^.*://' 2>&1)
	fi
	echo "$ou"
	return 0
}

# getnewcert()
# --------------------------
# Description: Download the CA cert file if not exist or if its timestamp is too old
# Input params: <none>
# Global variables used: $CONF_DIR, $CA_OLD_TIME_SEC
# External commans used: date
# Output: as getcert functions
# Return value: as getcert functions
# --------------------------
getnewcert() {
	local sec_old=0
	local sec_now=0
	if [ ! -f ${CONF_DIR}/ca.pem ]; then
	       getcert notify
	else
 		sec_old=$(date -r ${CONF_DIR}/ca.pem +%s)
		sec_now=$(date +%s)
		if [ $(( $sec_now - $sec_old )) -gt ${CA_OLD_TIME_SEC} ]; then
			getcert notify
		fi
	fi
}
# getcert()
# --------------------------
# Description: Download the CA cert file if not exist
# Input params: <none>
# Global variables used: $CONF_DIR, $XML_CERTS
# External commans used: mkdir, sed, grep, openssl, mv, rm, cat
# Phrases key used: errore:file:conf_dir, titolo:cert, download_url:ca:attendi, download_url:ca:ok, download_url:ca:non_ok
# Output: information messages during the download
# Return value: 
#   0 : all ok
#   1 : Unable to create the .p7m directory
#   2 : Unable to download the 'CA' at this time
# --------------------------
getcert() {
  local i
  mkdir -p ${CONF_DIR}
  if [ ! -d "${CONF_DIR}" ]; then
	  err "$(_msg 'errore:file:conf_dir')" "$(_msg 'titolo:cert')"
	return 1
  fi
  notify "$(_msg 'download_url:ca:attendi')" "$(_msg 'titolo:cert')"
  rotate_file ${CONF_DIR}/cnipa_signed.xml
  download "${XML_CERTS}" "${CONF_DIR}/cnipa_signed.xml"
  # cnipa_signed.xml now is only one line long so we add e return value before start tag and after tag (X509Certificate)
  for i in `sed -e 's/<X509Certificate/\n<X509Certificate/g' -e s'#</X509Certificate>#</X509Certificate>\n#g' ${CONF_DIR}/cnipa_signed.xml | grep '<X509Certificate'`; do
	  echo -e "-----BEGIN CERTIFICATE-----"
	  echo $i| sed -e 's/<\/*X509Certificate>//g'| openssl base64 -d -A| openssl base64
	  echo -e "-----END CERTIFICATE-----"
  done >${CONF_DIR}/ca.pem.partial
if [ -s ${CONF_DIR}/ca.pem.partial ]; then
	rotate_file "${CONF_DIR}/ca.pem"
	mv "${CONF_DIR}/ca.pem.partial" "${CONF_DIR}/ca.pem"
	if [ "$1" ]; then
		notify "$(_msg 'download_url:ca:ok') ${CONF_DIR}/ca.pem" "$(_msg 'titolo:cert')"
	else
		display "$(_msg 'download_url:ca:ok') ${CONF_DIR}/ca.pem" "$(_msg 'titolo:cert')"
	fi
else
	rm -f ${CONF_DIR}/ca.pem.partial
	if [ "$1" ]; then
		notify "$(_msg 'download_url:ca:non_ok')\n\n[logs]:\n `cat ${CONF_DIR}/.dwn.log`" "$(_msg 'titolo:cert')"
	else
		err_detail "$(_msg 'download_url:ca:non_ok')" "'[logs]:\n `cat ${CONF_DIR}/.dwn.log`'" "$(_msg 'titolo:cert')"
	fi
	return 2
fi
return 0
}

# from_base64_to_p7m()
# --------------------------
# Description: Converts a p7m file encoded in base64 to standard p7m
# Input params: 
#  $1: path of the file to convert
# External commans used: mktemp, openssl
# Output: path of the converted file
# Return value: 0
# --------------------------
from_base64_to_p7m() {
	local file_pem=$1
	local newp7m=$(mktemp --tmpdir "p7m_tmp.XXXXXXXXXX")
	# check if in base64 format to convert in original p7m
	openssl base64 -A -d -in "$file_pem" -out "$newp7m" 2>&1
	if [ -s "$newp7m" ]; then
		echo "$newp7m"
	else
		del_oldtmp_file "$newp7m"
		echo "$file_pem"
	fi
	return 0
}


# is_p7m()
# --------------------------
# Description: Check if the p7m file passed as a parameter is a true p7m
# Input params: 
#  $1: path of the file to check
# External commans used: openssl
# Output: 
#   0: all check is ok
#   1: $1 is not a p7m file
# Return value: 
#   0: all check is ok
#   1: $1 is not a p7m file
# --------------------------
is_p7m() {
	local file_test=$1
	local real_file_test=$(from_base64_to_p7m "$file_test")
	# check if in pem format
	openssl pkcs7 -print_certs -text -noout -inform pem -in "$real_file_test" >/dev/null 2>&1
	if [ $? == 0 ]; then
		echo "0"
		return 0
	fi
	# check if in der format
	openssl pkcs7 -print_certs -text -noout -inform der -in "$real_file_test" >/dev/null 2>&1
	if [ $? == 0 ]; then
		echo "0"
		return 0
	fi
	# check if CMS (and no SMIME) in pem format
	openssl cms -inform PEM -verify -noverify -nosigs -cmsout -noout -in "$real_file_test" >/dev/null 2>&1
	if [ $? == 0 ]; then
		echo "0"
		return 0
	fi
	# check if CMS (and no SMIME) in der format
	openssl cms -inform DER -verify -noverify -nosigs -cmsout -noout -in "$real_file_test" >/dev/null 2>&1
	if [ $? == 0 ]; then
		echo "0"
		return 0
	fi
	if [ "$real_file_test" != "$file_test" ]; then
		del_oldtmp_file "$real_file_test"
	fi
	echo "1"
	return 1
}

# getP7mType()
# --------------------------
# Description: Check if the p7m file passed as a parameter id smime or cms p7m type
# Input params: 
#  $1: path of the file to check
# External commans used: openssl
# Output: 
#   smime: smime file
#   cms: cms file
# Return value: 
#   0: smime or cms file
#   1: $1 is not a p7m file
# --------------------------
getP7mType() {
	local file_test=$1
	local real_file_test=$(from_base64_to_p7m "$file_test")
	# check if in pem format
	openssl pkcs7 -print_certs -text -noout -inform pem -in "$real_file_test" >/dev/null 2>&1
	if [ $? == 0 ]; then
		echo "smime"
		return 0
	fi
	# check if in der format
	openssl pkcs7 -print_certs -text -noout -inform der -in "$real_file_test" >/dev/null 2>&1
	if [ $? == 0 ]; then
		echo "smime"
		return 0
	fi
	# check if CMS (and no SMIME) in pem format
	openssl cms -inform PEM -verify -noverify -nosigs -cmsout -noout -in "$real_file_test" >/dev/null 2>&1
	if [ $? == 0 ]; then
		echo "cms"
		return 0
	fi
	# check if CMS (and no SMIME) in der format
	openssl cms -inform DER -verify -noverify -nosigs -cmsout -noout -in "$real_file_test" >/dev/null 2>&1
	if [ $? == 0 ]; then
		echo "cms"
		return 0
	fi
	if [ "$real_file_test" != "$file_test" ]; then
		del_oldtmp_file "$real_file_test"
	fi
	return 1
}

# from_pem_to_der()
# --------------------------
# Description: Converts from PEM to DER format
# Input params: 
#  $1: path of the file to convert
# External commans used: mktemp, openssl
# Output: path of the converted file
# Return value: 0
# --------------------------
from_pem_to_der() {
	local file_pem=$1
	local der=$(mktemp --tmpdir "p7m_tmp.XXXXXXXXXX")
	# check if in pem format to convert in der
	if [ "$P7MTYPE" = 'smime' ]; then
		# smime
		openssl pkcs7 -outform der -in "$file_pem" -out "$der" >/dev/null 2>&1
	else
		# cms
		openssl cms -inform PEM -verify -noverify -nosigs -cmsout -outform DER -out "$der" -in "$file_pem" >/dev/null 2>&1
	fi
	if [ $? != 0 ]; then
		del_oldtmp_file "$der"
		der="$file_pem"
	fi
	echo "$der"
	return 0
}

# verify()
# --------------------------
# Description: Check the correctness of the p7m file including the signatures
# Input params: 
#  $1: path of the file to verify
# Global variables used: $CONF_DIR
# External commans used: openssl, sed, grep, date
# Phrases key used: download_url:ca:mancante, openssl:verifica:errore:formato, titolo:openssl:verify, openssl:verifica:timestamp:mancante,
#   openssl:verifica:ok:ok, openssl:verifica:non_ok_scaduto:ok, openssl:verifica:non_ok_scaduto:non_ok, openssl:verifica:non_ok:ok,
#   openssl:verifica:non_ok:non_ok
# Output: Verification status messages
# Return value: 
#  0: p7m file is ok
#  1: The CA is missing, download it first
#  2: File format error
#  8: missed timestamps in p7m
# 10: Signature verification failed (certificate expired) and timestamps failed
# 11: Signature verification failed and timestamps failed, outside the validity of the certificate
# --------------------------
verify() {
	local i idx OLD_IFS R err
	local utc utctime verify_res now sn timestamp_readable
	local timestamp issuer notbefore notafter subject cn cf ou 
	local issuer_cn notbefore_ts notafter_ts 
	declare -a timestamps_array
	declare -a certs_orig_array
	declare -A serial_timestamps
	declare -A serial_certs
	declare -A utctime_hash
	declare -a verify_msg
	if [ ! -f "${CONF_DIR}/ca.pem" -o ! -s "${CONF_DIR}/ca.pem" ]; then
		warn "$(_msg 'download_url:ca:mancante')"
		return 1
	fi
	err=$(opensslVerify "$1" "DER" "no_out")
	R=$?
	if [ $R = "2" ]; then
		if [ -z "$2" ]; then
			err_detail "$(_msg 'openssl:verifica:errore:formato')" "$err" "$(_msg 'titolo:openssl:verify')"
		else 
			echo "$(_msg 'openssl:verifica:errore:formato');$err"
		fi
		return $R
	fi
	# in timestamps_array ci sono:
        #	negli elementi 0,2,4, ecc. (elementi pari) il serial del certificato di chi ha firmato
	#	negli elementi 1,3,5, ecc. (elementi dispari) l'UTCTIME in formato normalizzato con il locale impostato
	OLD_IFS=$IFS
	IFS=$'\n' 
	timestamps_array=($(getIssuerTimestamps "$1"))
	certs_orig_array=($(getCertsFields "$1"))
	IFS=$OLD_IFS
	for (( i=0; i<${#timestamps_array[*]}; i=$(($i+2)) )); do
          serial_timestamps[${timestamps_array[$i]}]=$i
	  utctime=${timestamps_array[$(($i+1))]}
	  utctime=$(getTs "${utctime}")
	  utctime_hash[$utctime]=${timestamps_array[$i]}
	done
	# in certs_orig_array ci sono:
	#	negli elementi 0,5,10, ecc. (elementi 0 + 5*n) il serial del certificato
	#	negli elementi 1,6,11, ecc. (elementi 1 + 5*n) l'issue
	#	negli elementi 2,7,12, ecc. (elementi 2 + 5*n) il notBefore (data di partenza del certificato)
	#	negli elementi 3,8,13, ecc. (elementi 3 + 5*n) il notAfter (data di scadenza del certificato)
	#	negli elementi 4,9,14, ecc. (elementi 4 + 5*n) il subject (Nome, cognome, CF, ecc)
	for (( i=0; i<${#certs_orig_array[*]}; i=$(($i+5)) )); do
		serial_certs[${certs_orig_array[$i]}]=$i
	done
	# Debug for certs and timestamps
	# echo -e "\ntimestamps_array:\n"
	# echo "${timestamps_array[*]}"
	# echo -e "\ncerts_orig_array:\n"
	# echo "${certs_orig_array[*]}"
	# echo -e "\nserial_timestamps:\n"
	# for x in "${!serial_timestamps[@]}"; do echo "$x = ${serial_timestamps[$x]}"; done
	# echo -e "\nserial_certs:\n"
	# for x in "${!serial_certs[@]}"; do echo "$x = ${serial_certs[$x]}"; done
	# echo -e "\nutctime_hash:\n"
	# for x in "${!utctime_hash[@]}"; do echo "$x = ${utctime_hash[$x]}"; done
	# echo "${!utctime_hash[@]}" | sed -e 's/ /\n/g' |sort -n 
	# exit
	# Debug end: for certs and timestamps

	# verify_res: indica se 0 che le firme e i loro timestamp sono corretti; se >0 c'e' un errore
	verify_res=0
	now=$(date "+%s")
	if [ ${#timestamps_array[*]} -eq 0 ]; then 
		verify_msg[0]="$(_msg 'openssl:verifica:timestamp:mancante')"
		verify_res=8
	else
		idx=-1
		for utc in $(echo "${!utctime_hash[@]}" | sed -e 's/ /\n/g' | sort -n); do
			sn=${utctime_hash[$utc]}
			idx=$(($idx + 1 ))
			idx_ts=${serial_timestamps[$sn]}
			idx_cert=${serial_certs[$sn]}
			timestamp_readable=${timestamps_array[$(( $idx_ts + 1 ))]}
			timestamp=$(getTs "${timestamp_readable}")
			issuer=${certs_orig_array[$(( $idx_cert + 1 ))]}
			notbefore=${certs_orig_array[$(( $idx_cert + 2 ))]}
			notafter=${certs_orig_array[$(( $idx_cert + 3 ))]}
			subject=${certs_orig_array[$(( $idx_cert + 4 ))]}
			cn=$(getCn "$subject")
			cf=$(getCf "$subject")
			ou=$(getOu "$subject")
			issuer_cn=$(getCn "$issuer")
			notbefore_ts=$(getTs "${notbefore}")
			notafter_ts=$(getTs "${notafter}")

			# Debug for summury data
			# echo -e "serialNumber: $sn"
			# echo -e "\t idx_ts=$idx_ts, idx_cert=$idx_cert"
			# echo -e "\t timestamp_readable=$timestamp_readable, timestamp=$timestamp"
			# echo -e "\t issuer=$issuer"
			# echo -e "\t notBefore=$notbefore (ts=$notbefore_ts), notAfter=$notafter (ts=$notafter_ts)"
			# echo -e "\t subject=$subject"
			# echo -e "\t --------"
			# echo -e "\t cn=$cn, cf=$cf, ou=$ou"
			# echo -e "\t issuer_cn=$issuer_cn"
			# Debug end for summary data
			verify_res=0
			if [ $R = "0" ]; then
				verify_msg[$idx]="$(_msg 'openssl:verifica:ok:ok' "${cn}" "${timestamp_readable}" "${ou}" "${cf}" "${issuer_cn}" "${notbefore}" "${notafter}")"
			
			elif [ "${now}" -lt "${notbefore_ts}" -o "${now}" -gt "${notafter_ts}" ]; then
				if [ "${timestamp}" -ge "${notbefore_ts}" -a "${timestamp}" -le "${notafter_ts}" ]; then
					verify_msg[$idx]="$(_msg 'openssl:verifica:non_ok_scaduto:ok' "${cn}" "${timestamp_readable}" "${ou}" "${cf}" "${issuer_cn}" "${notbefore}" "${notafter}")"
				else
					verify_msg[$idx]="$(_msg 'openssl:verifica:non_ok_scaduto:non_ok' "${cn}" "${timestamp_readable}" "${ou}" "${cf}" "${issuer_cn}" "${notbefore}" "${notafter}")"
					verify_res=10
				fi
			else
				if [ "${timestamp}" -ge "${notbefore_ts}" -a "${timestamp}" -le "${notafter_ts}" ]; then
					verify_msg[$idx]="$(_msg 'openssl:verifica:non_ok:ok' "${cn}" "${timestamp_readable}" "${ou}" "${cf}" "${issuer_cn}" "${notbefore}" "${notafter}")"
				else
					verify_msg[$idx]="$(_msg 'openssl:verifica:non_ok:non_ok' "${cn}" "${timestamp_readable}" "${ou}" "${cf}" "${issuer_cn}" "${notbefore}" "${notafter}")"
					verify_res=11
				fi
			fi

		done
	fi
	echo "${verify_msg[*]}"
	return $verify_res
}

# cert()
# --------------------------
# Description: Extract certificates from a pkcs7 file
# Input params: 
#  $1: path of pkcs7 file
# Global variables used: $CONF_DIR
# External commans used: openssl
# Phrases key used: download_url:ca:mancante
# Output: the certs
# Return value: openssl pkcs7 return valus
# --------------------------
cert() {
	local str R
	if [ ! -f "${CONF_DIR}/ca.pem" -o ! -s "${CONF_DIR}/ca.pem" ]; then
		echo "$(_msg 'download_url:ca:mancante')"
		return 1
	fi
	if [ "${P7MTYPE}" = "smime" ]; then
		# smime
		str=`openssl pkcs7 -print_certs -text -inform der -in "$1" 2>&1`
		R=$?
	else
		# cms
		local certsfile=$(mktemp --tmpdir "p7m_tmp.XXXXXXXXXX")
		openssl cms -verify -inform DER -CAfile "${CONF_DIR}/ca.pem" -certsout ${certsfile} -out /dev/null -in "$1" -out /dev/null 2>/dev/null
		str=$(openssl crl2pkcs7 -nocrl -certfile ${certsfile} | openssl pkcs7 -print_certs -text)
		R=$?
		del_oldtmp_file "${certsfile}"
	fi
	echo "$str"
	return $R
}

# debug_pkcs7()
# --------------------------
# Description: Debug with asn1parse a pkcs7 file
# Input params: 
#  $1: path of the file to debug
# Global variables used: $P7MTYPE
# External commans used: openssl
# Output: the asn1 debug output
# Return value: openssl asn1parse or cms fields
# --------------------------
debug_pkcs7() {
	local str R
	if [ "${P7MTYPE}" = "smime" ]; then
		# smime
		str=$(openssl asn1parse -inform der -in "$1" 2>&1)
		R=$?
	else
		# cms
		str=$(openssl cms -inform DER -verify -noverify -nosigs -cmsout -print -text -in "$1" 2>&1)
		R=$?
	fi
	echo "$str"
	return $R
}

# getxslenvs()
# --------------------------
# Description: Set the environment xsl_file and xsl_url based on version in $1
# Input params: 
#  $1: the version of xsl file
# Global variables used: $xsl_file, $xsl_url, $XSL_V12, $XSL_V12_URL, $XSL_V11, $XSL_V11_URL
# Output: <none>
# Return value: 0
# --------------------------
getxslenvs() {
	local version=$1
	unset xsl_file xsl_url
	if [ "$version" = "fpr12" ]; then
		xsl_file=${XSL_V12}
		xsl_url=${XSL_V12_URL}
	elif [ "$version" = "1.1" ]; then
		xsl_file=${XSL_V11}
		xsl_url=${XSL_V11_URL}
	fi
}

# copyxslfile()
# --------------------------
# Description: copy xsl file from $CONF_DIR to $2 dir
#              xsl file is based on $1 version of xml (inside fattura elettronica)
#              the xsl will be downloaded if it does not exist or if it is too old based on $CA_OLD_TIME_SEC
# Input params: 
#  $1: version of xsl
#  $2: dir where copy xsl file from $CONF_DIR 
# Global variables used: $CONF_DIR, $xsl_file, $xsl_file, $xsl_url
# External commans used: cp
# Phrases key used: download_url, titolo:download
# Output: <none>
# Return value: 0
# --------------------------
copyxslfile() {
	local version=$1
	local dir=$2
	local xsl url sec_old sec_now
	getxslenvs $version
	if [ ! -f "${CONF_DIR}/$xsl_file" -o ! -s "${CONF_DIR}/$xsl_file" ]; then
		notify "$(_msg 'download_url' $xsl_file)" "$(_msg 'titolo:download')"
		download "$xsl_url" "${CONF_DIR}/$xsl_file"
	fi
	if [ -e "${CONF_DIR}/$xsl_file" ]; then
		cp "${CONF_DIR}/$xsl_file" "$dir/$xsl_file"
	fi
}

# p7mplugin()
# --------------------------
# Description: check if $1 is a fattura elettronica file and copy the right xsl
# Input params: 
#  $1: path of fattura elettronica file
# Global variables used: $IS_FATTURA, $xsl_file
# External commans used: file, grep, sed, dirname
# Output: <none>
# Return value: 0
#   IS_FATTURA=1 if $1 is a fattura elettronica
# --------------------------
p7mplugin() {
	local file=$1
	local t=`file -b --mime-type "$file"`
	if [ -n "$t" -a "$t" = 'application/xml' ]; then
		t='text/xml'
	fi
	local version
	local testif_fatturaelettronica=$(grep -E '<FatturaElettronicaHeader' "$file")
	local tag_FatturaElettronica=$(grep -E '<(.*:)?FatturaElettronica ' "$file")
	local testif_xmlstylesheet=$(grep -E 'xml-stylesheet' $file)
	if [ "$t" = 'text/xml' -a -n "$testif_fatturaelettronica" ]; then
		# check if fattura elettronica
		# found version and make all lowercase
		version=$(echo $tag_FatturaElettronica | sed -e 's/^.*versione="\([^"]*\).*$/\1/' | tr '[A-Z]' '[a-z]')
		getxslenvs $version
		if [ -z "$testif_xmlstylesheet" ]; then
			sed -i 's/\(<\([[:alnum:]]*:\)*FatturaElettronica \)/<\?xml-stylesheet type="text\/xsl" href="'$xsl_file'"\?>\1/' "$file"
		fi
		copyxslfile "$version" "$(dirname $file)"
		IS_FATTURA=1

	fi
}

# getP7mFile()
# --------------------------
# Description: Open dialog box (if possible) to select a p7m file if not yet present
# Input params: 
#  $1: file p7m if already present
# Global variables used: $out, $XDIALOG, $PWD
# External commans used: kdialog, zenity
# Phrases key used: titolo:seleziona:p7m
# Output: the p7m selected or $1
# Return value: 0
# --------------------------
getP7mFile() {
	local file=''
	if [ -n "$1" -o "$out" != 'g' ]; then
		file="$1"
	elif [ "$XDIALOG" = 'kdialog' ]; then
		file=$(kdialog --getopenfilename --title="$(_msg 'titolo:seleziona:p7m')" $PWD 'P7M file (*.p7m)')
	elif [ "$XDIALOG" = 'zenity' ]; then
		file=$(zenity --file-selection --title="$(_msg 'titolo:seleziona:p7m')" --file-filter='*.p7m')
	fi
	echo "$file"
	return 0
}

# getHelp()
# --------------------------
# Description: Display help usage message for p7m
# Input params: 
#  $1: Message to prepend to the help usage message
# Phrases key used: p7m:usage
# Output: Display 'p7m:usage' phrase
# Return value: 0
# --------------------------
getHelp() {
	display "$(_msg 'p7m:usage' "$1")"	
}

### START MAIN ###

if [ -n "${CONF_DIR}" -a ! -d "${CONF_DIR}" ]; then
	mkdir -p "${CONF_DIR}"
fi
if [ -f "${CONF_DIR}/p7m_config" ]; then
	# in questo file puoi modificare i messaggi ed aggiungere lingue, i vari programmi da utilizzare ed altro
	source "${CONF_DIR}/p7m_config"
fi

# Set same environment variables
L=$(get_lang_message)
DWN=$(find_command ${DWL_ORDER})
OPEN=$(find_command ${OPEN_ORDER})
XDIALOG=$(find_command ${DIALOG_ORDER})

while getopts ":pvcdxgh" arg; do
  case $arg in
      p)
	 op='p'
      ;;
      v)
          op='v'
      ;;
      c)
          op='c'
      ;;
      d)
	  op='d'
      ;;
      x)
	  op='x'
      ;;
      g)
	  out='g'  
      ;;
      h)
	  op='h'
      ;;
  esac
done
if [ "$op" = 'h' ]; then
	getHelp " "
	exit 0
fi
if [ "$op" = 'p' ]; then
	getcert
	R=$?
	exit $R
fi
shift $(($OPTIND - 1))
file=$@
file=$(getP7mFile "$file")
if [ -z "$file" ]; then
	getHelp "$(_msg 'errore:file:ext')"
  exit 1
fi
if [ ! -f "$file" ]; then
	getHelp "$(_msg 'errore:file:non_esiste') ($file)"
  exit 2
fi
orig_path=$(dirname "$file")
name_file=$(echo ${file} | tr '[ A-Z]' '[_a-z]')
b1=$(basename "$name_file")
b2=$(basename "$name_file" .p7m)
if [ "$b1" = "$b2" ]; then
	getHelp "$(_msg 'errore:file:ext')"
  exit 3
fi
if [ ! `which openssl 2>/dev/null` ]; then
	err "$(_msg 'eseguibile:openssl:non_trovato')" "$(_msg 'it:titolo:openssl')"
  exit 4
fi

declare -a out_continue_array
declare -a unlink_files
checkfile="$file"
# p7m_attach: [Variabile  globale] Nome del file estratta dal .p7m
p7m_attach=""
level=-1
op_continue=1
op_continue_ret=0
op_title=''
if [ $(is_p7m "$checkfile") -ne 0 ]; then 
	op_continue=0
	out_continue_array[0]=$(_msg 'errore:file:ext:bad')
fi
while [ $op_continue_ret -eq 0 -a $(is_p7m "$checkfile") -eq 0 ]; do
	level=$(( $level + 1 ))
	P7MTYPE=$(getP7mType "$checkfile")
	# Se necessario converto da base64
	myfile_uu=$(from_base64_to_p7m "$checkfile")
	unlink_files+=("$myfile_uu")
	# Se necessario converto il file da PEM a DER
	myfile=$(from_pem_to_der "$myfile_uu")
	unlink_files+=("$myfile")
	
	if [ $level -eq 0 ]; then 
		getnewcert
	fi
	if [ "$op" = 'v' ]; then
		op_continue=0
		out_continue_array[$level]=$(verify "$myfile")
		op_continue_ret=$?
		if [ $op_continue_ret -eq 0 ]; then
			if [ -z "$op_title" ]; then
				op_title="openssl:verifica:title:ok"
			fi
		else
			op_title="openssl:verifica:title:non_ok"
		fi
	elif [ "$op" = 'c' ]; then
		op_continue=0
		out_continue_array[$level]=$(cert "$myfile")
		op_continue_ret=$?
		op_title="titolo:openssl:cert"
	elif [ "$op" = 'd' ]; then
		op_continue=0
		out_continue_array[$level]=$(debug_pkcs7 "$myfile")
		op_continue_ret=$?
		op_title="titolo:openssl:asn1parse"
	elif [ -f "${CONF_DIR}/ca.pem" -a -s "${CONF_DIR}/ca.pem" ]; then
		errv=$(verify "$myfile")
		codev=$?
		if [ $codev != "0" ]; then
			warn_yesno "$(_msg 'openssl:verifica:errore:continuo')" "" "$(_msg 'titolo:openssl')"
			if [ $? != 0 ]; then
				del_oldtmp_file "${unlink_files[*]}"
				exit 5
			fi
		fi
	fi
	checkfile=$(mktemp --tmpdir "p7m_tmp.XXXXXXXXXX")
	err=`openssl ${P7MTYPE} -verify -noverify -in "$myfile" -inform DER -out "$checkfile" 2>&1`
	code=$?
	unlink_files+=("$checkfile")
	if [ $code != "0" ]; then
		warn_yesno "$(_msg 'openssl:verifica:errore:continuo')" "$err" "$(_msg 'titolo:openssl')"
		if [ $? != 0 ]; then
			del_oldtmp_file "${unlink_files[*]}"
			exit 5
		fi
	fi
done
if [ $op_continue -eq 0 ]; then
	declare -a out_msg
	indent=''
	for (( i=$(( ${#out_continue_array[*]} -1 )); i>=0; i=$(($i-1)) )); do
		level=$(( ${#out_continue_array[*]} -1 - $i ))
		if [ $level -gt 0 ]; then 
			indent="$indent    "
			out_msg[$level]=$(echo -e "\n${DOWN_RIGHT_ARROW} ** livello $level **\n\n${out_continue_array[$i]}" | sed "s/^/$indent/g")"\n"
		elif [ ${#out_continue_array[*]} -gt 1 ]; then
			out_msg[$level]=$(echo "\n ** livello $level **\n\n${out_continue_array[$i]}")
		else
			out_msg[$level]=$(echo "\n${out_continue_array[$i]}")

		fi
	done
	display "${out_msg[*]}" "$(_msg ${op_title})"
	del_oldtmp_file "${unlink_files[*]}"
	exit $op_continue_ret;
fi
if [ "$checkfile" = "$file" ]; then
	exit 2
fi
newfile=$checkfile
t=`file -b --mime-type "$newfile"`
if [ "$t" = 'text/xml' ]; then
	t='text/xml|application/xml';
fi
p7m_attach=${newfile}
nf="${b2}"
if [ -n "$t" -a -f "${MIMETYPES}" ]; then
	read -a exts <<<$(grep -E "$t" "${MIMETYPES}")
	if [ -n "${exts[1]}" ]; then
		b3=$(basename "$b2" ".${exts[1]}")
		if [ "$b3" = "$b2" ]; then
			nf="${b2}.${exts[1]}"
		else
			nf="${b2}"
		fi
		nf=$(echo ${nf} | tr '[ A-Z]' '[_a-z]')
		p7m_attach=$(mktemp --tmpdir "p7m_tmp.XXXXXXXXXX-${nf}")
		mv "${newfile}" "${p7m_attach}"
	fi
fi
# Cancellazione file temporanei
del_oldtmp_file "${unlink_files[*]}"
IS_FATTURA=""
p7mplugin "${p7m_attach}"
if [ "$op" == 'x' ]; then
	if [ -e "${orig_path}/${nf}" ]; then
		warn_yesno "$(_msg 'file:sovrascivere') ${orig_path}/${nf}" "" "$(_msg 'titolo:p7m')"
		if [ $? != 0 ]; then
			exit 2
		fi
	fi
	err=$( mv "${p7m_attach}" "${orig_path}/${nf}" )
	if [ $? != "0" ]; then
		err "$(_msg 'file:diritti:scrittura') ${orig_path}\n$(_msg 'file:diritti:scrittura:alternativa') ${p7m_attach}"
	else
		notify "$(_msg 'openssl:estrazione:percorso') '${orig_path}/${nf}'\n[tipo: $t]"
	fi
elif [ -n "${OPEN}" ]; then
	# display "$(_msg 'eseguibile:open_file:non_trovato') ${p7m_attach}"
	${OPEN} "${p7m_attach}"
	exit 0
elif [ -t 1 -a -n "$IS_FATTURA" ]; then
	more "${p7m_attach}"
else 
	display "$(_msg 'eseguibile:open_file:non_trovato')  '${p7m_attach}'\n[tipo: $t]"
	exit 0
fi

# ########################################################################
#      Copyright (c) 2018 Enio Carboni - Italy
#
#      This file is part of p7m.
#
#    p7m is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    p7m is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with p7m.  If not, see <http://www.gnu.org/licenses/>.
# ########################################################################
